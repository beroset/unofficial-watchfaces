#! /bin/bash
#
# watchface - Utility script for managing AsteroidOS watchfaces
#
# This script provides a comprehensive set of tools for deploying, testing,
# and managing watchfaces for AsteroidOS smartwatches. It supports both
# SSH (Developer Mode) and ADB (ADB Mode) communication methods.
#
# Key features:
# - Deploy watchfaces to an AsteroidOS watch
# - Test watchfaces locally using qmlscene
# - Clone existing watchfaces to create new ones
# - Interactive menu systems (text-based and GUI)
# - Automatic font configuration handling for custom fonts
# - Preview image generation and conversion
#
# Usage: ./watchface [options] [command] [arguments]
# See showHelp() function for detailed usage information.
#

# Version number of this script
VERSION="1.2"

# Display the current version of the script
function showVersion {
    echo "watchface v${VERSION}"
}

# Display comprehensive help information about the script
# This function prints the version and complete usage documentation
# including all available options and commands.
function showHelp {
    showVersion
    cat << EOF
watchface [option] [command...]
Utility functions for AsteroidOS watchfaces.  By default, uses "SSH Mode"
over ssh, but can also use "ADB Mode" using ADB.

Available options:
-h or --help            print this help screen and quit
-a or --adb             use ADB command to communicate with watch
-b or --boot            reboot watch after deploying multiple watchfaces
-c or --circlewall WP   set the wallpaper for circular watchface thumbnail to the named file (WP)
-e or --every           select every watchface (deploy only)
-g or --gui             use the GTK+ gui
-p or --port            specify an IP port to use for ssh and scp commands
-q or --qemu            communicate with QEMU emulated watch (same as -r localhost -p 2222 )
-r or --remote          specify the remote (watch)  name or address for ssh and scp commands
-t or --transport       when used win ADB mode, specifies the transport id
-w or --wall WP         set the wallpaper for deploy or test to the named file (WP)
-v or --verbose         print verbose messages (useful for debugging)

Available commands:
update          use git to update your local copy of the unoffical-watchfaces repository
version         display the version of this program and exit
deploy WF       push the named watchface to the watch and activate it
deployall       deploy all watchfaces
clone WF NEWWF  clone the named watchface WF to new watchface NEWWF
test WF         test the named watchface on the computer using qmlscene
raw QMLFILE     test a raw QML file without the standard directory structure

EOF
}

# ============================================================================
# Environment Configuration Variables
# ============================================================================
# These variables are set based on parsed command-line switches and control
# how the script communicates with the watch and which features are enabled.

# SSH connection settings (default for Developer Mode)
# These are the defaults for SSH access to a watch on the local network
WATCHPORT=22                    # SSH port number
WATCHADDR=192.168.2.15          # Default IP address of the watch

# QEMU emulator connection settings
# These are the defaults for local QEMU target
QEMUPORT=2222                   # SSH port for QEMU
QEMUADDR=localhost              # QEMU runs on localhost

# Communication method flags
ADB=false                       # Use ADB mode instead of SSH (default: false)
GUI=false                       # Use GUI menu with zenity (default: false)

# Interactive mode control
# Only show interactive prompt if the user hasn't
# already specified a command on the command line
SKIP_INTERACTIVE_PROMPT=false

# Wallpaper configuration
# Default wallpaper files unless user specifies others
WALLPAPER="background.jpg"              # Square display wallpaper
WALLPAPER_ROUND="background-round.jpg"  # Circular display wallpaper

# Watchface deployment settings
DEFAULTOPTION=OFF               # Default to all watchfaces unselected for deploy
DEPLOY_ALL=false                # Default to not deploying all watchfaces

# Debug and logging
VERBOSE_MESSAGES=false          # Print verbose messages to stderr (default: false)

# ADB transport configuration
# Transport id is not needed unless multiple watches are connected
TRANSPORT_ID=

# Command execution state
COMMAND=""                      # Command to execute (deploy, test, clone, etc.)
declare -a COMMAND_ARGS=()      # Arguments for the command

# ============================================================================
# Core Communication Functions
# ============================================================================

# Execute a command on the watch as a specific user
# This function abstracts the difference between ADB and SSH communication
# Args:
#   $1 - user: Either "root" or "ceres" - the user to run the command as
#   $2 - cmd: The shell command to execute on the watch
# Returns: Exit status of the remote command
function runWatchCommand {
    local user="$1"
    local cmd=$2
    case ${user} in
        root)
            # Execute command as root user
            if [ "$ADB" = "true" ] ; then
                # ADB mode: use adb shell with optional transport ID
                adb ${TRANSPORT_ID} shell "${cmd}"
            else
                # SSH mode: connect via SSH as root
                ssh -p "${WATCHPORT}" -t root@"${WATCHADDR}" ${cmd}
            fi
            ;;
        ceres)
            # Execute command as ceres user (the main user on AsteroidOS)
            if [ "$ADB" = "true" ] ; then
                # ADB mode: use su to switch to ceres user
                printf -v cmd %q "${cmd}"
                adb ${TRANSPORT_ID} shell "su -l -c ${cmd} ceres"
            else
                # SSH mode: connect via SSH as ceres
                ssh -p "${WATCHPORT}" -t ceres@"${WATCHADDR}" ${cmd}
            fi
            ;;
        *)
            # Invalid user specified
            echo "Error: unknown watch user ${user}"
            ;;
    esac
}

# Print a message only if verbose mode is enabled
# Args:
#   $1 - message: The message to print
function printVerbose {
   local message="$1"
   if [ "${VERBOSE_MESSAGES}" = "true" ] ; then
       echo "$message"
   fi
}

# Set a dconf configuration setting on the watch
# dconf is the configuration system used by AsteroidOS
# Args:
#   $1 - dconfsetting: The dconf key path (e.g., "/desktop/asteroid/watchface")
#   $2 - filename: The file path to set as the value
function setDconf {
    local dconfsetting="$1"
    local filename="$2"
    # Write the dconf setting as the ceres user with the file:// URI prefix
    runWatchCommand "ceres" "dconf write ${dconfsetting} '\"file://${filename}\"'"
}

# Push files or directories to the watch
# This function abstracts the difference between ADB push and SCP
# Args:
#   $1 - user: The user account (for SSH mode, ignored for ADB)
#   $2 - sourcedir: Local source file or directory path
#   $3 - destdir: Remote destination path on the watch
function pushFiles {
    local user="$1"
    local sourcedir="$2"
    local destdir="$3"
    if [ "$ADB" = "true" ] ; then
        # ADB mode: use adb push with optional transport ID
        adb ${TRANSPORT_ID} push ${sourcedir} "${destdir}"
    else
        # SSH mode: use scp with custom port
        scp -P"${WATCHPORT}" -r ${sourcedir} "${user}@${WATCHADDR}:${destdir}"
    fi
}

# Push a watchface directory structure to the watch
# Args:
#   $1 - Watchface directory path containing usr/share/* structure
function pushWatchface {
    # Push all files from the watchface's usr/share subdirectory
    pushFiles "root" "${1}"'/usr/share/*' "/usr/share/"
}

# Push a wallpaper image to the watch and set it as the active background
# Args:
#   $1 - source: Local path to the wallpaper image file
function pushWallpaper {
    local source="$1"
    local wallpaper
    # Extract just the filename from the path
    wallpaper="$(basename "$1")"
    # Construct the destination path on the watch
    local destination="/usr/share/asteroid-launcher/wallpapers/full/${wallpaper}"
    # Upload the wallpaper file
    pushFiles "root" "${source}" "${destination}"
    # Set the wallpaper as active in dconf
    setDconf "/desktop/asteroid/background-filename" "${destination}"
}

# Restart the ceres user session on the watch
# This is necessary after deploying new watchfaces or fonts
# to make them available to the launcher
function restartCeres {
    runWatchCommand "root" "systemctl restart user@1000"
}

# Reboot the entire watch
# Sometimes needed when ceres restart doesn't properly reset everything
function rebootWatch {
    runWatchCommand "ceres" "reboot"
}

# Activate a specific watchface on the watch
# Args:
#   $1 - Watchface name (without .qml extension)
function activateWatchface {
    # Set the active watchface in dconf to the specified QML file
    setDconf "/desktop/asteroid/watchface" "/usr/share/asteroid-launcher/watchfaces/${1}.qml"
}

# ============================================================================
# Watchface Management Functions
# ============================================================================

# Clone a watchface to create a new one with a different name
# This copies all files and replaces occurrences of the source name
# with the destination name in paths and QML files
# Args:
#   $1 - source_path: Source watchface path (can be absolute)
#   $2 - dest_name: Destination watchface name (relative to CWD)
function watchfaceClone {
    local source_path="$1"
    local dest_name="$2"
    local files
    
    # Validate that the source path exists
    if [ ! -d "${source_path}" ] ; then
        echo "Error: source watchface path \"${source_path}\" does not exist" >&2
        exit 1
    fi
    
    # Extract just the watchface name from the source path (last component)
    local source_name
    source_name=$(basename "${source_path}")
    
    # Find all files in the source watchface recursively
    mapfile -t files <<<"$(cd "${source_path}" && find . -type f | sed 's|^\./||')"
    
    # Iterate through each file in the source watchface
    for file in "${files[@]}" ; do
        # Skip empty lines from the file list
        if [[ -z "${file}" ]] ; then
            continue
        fi
        
        # Replace source watchface name with destination name in the path
        local dest_file
        local destdir
        dest_file="${file//${source_name}/${dest_name}}"
        destdir="${dest_name}/$(dirname "${dest_file}")"
        
        # Create destination directory structure
        mkdir -p "${destdir}"
        # Copy the file
        cp "${source_path}/${file}" "${dest_name}/${dest_file}"
        
        # For QML files, replace watchface name within the file contents
        local extension="${dest_file##*.}"
        if [ "${extension}" = "qml" ] ; then
            # Use sed to replace all occurrences of source name with dest name
            sed -i "s/${source_name}/${dest_name}/g" "${dest_name}/${dest_file}"
        fi
    done
}

# Find a watchface by name, searching CWD first, then script directory
# This allows users to work on watchfaces in any location
# Args:
#   $1 - watchface_name: Watchface name (without trailing '/')
# Returns:
#   Outputs the full path to the watchface directory
#   Returns 0 if found, 1 if not found
function findWatchface {
    local watchface_name="$1"
    local cwd_path="${PWD}/${watchface_name}"
    local script_path="${SCRIPT_DIRPATH}/${watchface_name}"
    
    # Check current working directory first
    # A valid watchface must have the usr/share/asteroid-launcher/watchfaces/ structure
    if [[ -d "${cwd_path}/usr/share/asteroid-launcher/watchfaces/" ]] ; then
        echo "${cwd_path}"
        return 0
    fi
    
    # Then check script directory (where the official watchfaces are)
    if [[ -d "${script_path}/usr/share/asteroid-launcher/watchfaces/" ]] ; then
        echo "${script_path}"
        return 0
    fi
    
    # Watchface not found in either location
    echo ""
    return 1
}

# Deploy a watchface to the watch
# Args:
#   $1 - sourcewatchfacename: Name of the watchface to deploy
#   $2 - activate: "true" to activate the watchface and push wallpaper, "false" otherwise
function deployface {
    # Get the short name, stripping trailing '/' if any
    local sourcewatchfacename="${1%/*}"
    local activate="$2"
    
    # Find the watchface directory
    if ! sourcewatchfacedir=$(findWatchface "${sourcewatchfacename}") ; then
        exit 1
    fi
    
    echo "Deploying ${sourcewatchfacename}"
    # Push the watchface files to the watch
    pushWatchface "${sourcewatchfacedir}"
    
    # If this is the first (or only) watchface being deployed, activate it
    if [ "${activate}" = "true" ] ; then
        activateWatchface "${sourcewatchfacename}"
        # Also push wallpaper if one is specified
        if [ -f "${WALLPAPER}" ] ; then
            pushWallpaper "${WALLPAPER}"
        fi
    fi
}

# Delete a temporary fontconfig configuration file
# This is called as a cleanup function via trap
# Args:
#   $1 - temp_font_config: Path to the temporary fontconfig file
function deleteTempFontconfig {
    local temp_font_config="$1"
    printVerbose "Deleting temporary fontconfig config file \"${temp_font_config}\""
    rm -f "${temp_font_config}"
}

# Test a watchface locally using qmlscene
# This function sets up the environment to test a watchface on the computer
# without deploying it to the watch. It handles custom fonts by creating
# temporary fontconfig configuration.
# Args:
#   $1 - sourcewatchfacename: Name of the watchface to test
function testface {
    # Get the short name, stripping trailing '/' if any
    local sourcewatchfacename="${1%/*}"
    
    # Find the watchface directory
    if ! sourcewatchfacedir=$(findWatchface "${sourcewatchfacename}") ; then
        exit 1
    fi
    
    echo "Testing ${sourcewatchfacename}"

    # Check if the watchface has custom fonts
    WATCHFACE_FONTS_PATH="${sourcewatchfacedir}/usr/share/fonts/"

    if [ -d "${WATCHFACE_FONTS_PATH}" ]; then
        printVerbose "Watchface has custom fonts in path \"${WATCHFACE_FONTS_PATH}\""

        # Create a temporary fontconfig configuration file that points to the
        # fonts subdirectory of the watchface. This allows Qt to load the font
        # from that local directory - very useful when testing a watch, because
        # then, installing that font is not necessary. The temporary config is
        # generated in the local fontconfig config directory to let fontconfig
        # find it.
        # This is better than setting the FONTCONFIG_FILE environment variable
        # to point to the autogenerated file, because the latter approach will
        # use the autogenerated config file as a full replacement for the system
        # config. This causes the Qt UI itself to not find fonts for its widgets,
        # and can also cause the watchface to not show certain glyphs if they
        # are only available in fallback fonts.

        # Check for the presence of the base fontconfig path. If it does not
        # exist, then the autogenerated config below probably would not work
        # because fontconfig is not present or configured in an unknown fashion.
        # Exit with an error in that case.
        LOCAL_FONTCONFIG_BASE_PATH="${XDG_CONFIG_HOME:-$HOME/.config}/fontconfig"
        if [ ! -d "${LOCAL_FONTCONFIG_BASE_PATH}" ]; then
            echo "Cannot generate temporary fontconfig config file; " \
                 "fontconfig path ${LOCAL_FONTCONFIG_BASE_PATH} does not exist" >&2
            exit 1
        fi

        # Create the conf.d subdirectory if it doesn't exist
        LOCAL_FONTCONFIG_PATH="${LOCAL_FONTCONFIG_BASE_PATH}/conf.d"
        mkdir -p "$LOCAL_FONTCONFIG_PATH"
        local temp_font_config
        # Use 9999- prefix to make sure this autogenerated configuration is applied
        # last, since fontconfig will list the config files in lexicographic order.
        # Also, the .conf suffix is used, since fontconfig requires that suffix;
        # it ignores files that do not end with ".conf".
        temp_font_config=$(mktemp -p "$CWD/$LOCAL_FONTCONFIG_PATH" --suffix=".conf"  -t 9999-temp_font_config.XXXXXX) || { echo "Failed to generate temporary fontconfig config file" >&2; exit 1; }

        printVerbose "Generating temporary fontconfig config file \"${temp_font_config}\""

        # Set up a trap to delete the temporary fontconfig file on exit
        trap "deleteTempFontconfig \"${temp_font_config}\"" EXIT

        # Generate the fontconfig XML configuration
        cat <<EOF > "${temp_font_config}"
<?xml version="1.0"?><!DOCTYPE fontconfig SYSTEM "fonts.dtd">
<fontconfig>
    <dir>${WATCHFACE_FONTS_PATH}/</dir>
</fontconfig>
EOF
    else
        printVerbose "Watchface has no custom fonts"
    fi

    # Ensure wallpaper files exist, checking in script directory if needed
    if [ ! -f "${WALLPAPER}" ] ; then
        WALLPAPER="${SCRIPT_DIRPATH}/${WALLPAPER}"
    fi
    if [ ! -f "${WALLPAPER_ROUND}" ] ; then
        WALLPAPER_ROUND="${SCRIPT_DIRPATH}/${WALLPAPER_ROUND}"
    fi
    
    # Launch qmlscene with the watchface
    # Arguments: watchface_name, wallpaper, wallpaper_round, watchface_dir, loader.qml, fake-components
    qmlscene "${sourcewatchfacename}" "${WALLPAPER}" "${WALLPAPER_ROUND}" "${sourcewatchfacedir}/usr/share/asteroid-launcher/watchfaces/" "${SCRIPT_DIRPATH}/loader.qml" -I "${SCRIPT_DIRPATH}/fake-components"
    
    # After testing, convert any preview images that were generated
    convertPreviews "${sourcewatchfacename}" "${sourcewatchfacedir}"
}

# Test a raw QML file without the standard watchface directory structure
# This is useful for quick prototyping or testing standalone QML files
# Args:
#   $1 - qmlfile: Path to the QML file to test
function testraw {
    local qmlfile="$1"
    
    # Validate that the QML file exists
    if [ ! -f "${qmlfile}" ] ; then
        echo "Error: QML file \"${qmlfile}\" does not exist" >&2
        exit 1
    fi
    
    # Get absolute path and extract directory components
    local abs_qmlfile=$(readlink -f "${qmlfile}")
    local qml_dir=$(dirname "${abs_qmlfile}")
    local qml_basename=$(basename "${abs_qmlfile}")
    local qml_name="${qml_basename%.qml}"  # Remove .qml extension
    
    echo "Testing raw QML file: ${abs_qmlfile}"
    printVerbose "QML directory: ${qml_dir}"
    
    # Check for fonts in a 'fonts' subdirectory next to the QML file
    if [ -d "${qml_dir}/fonts" ]; then
        WATCHFACE_FONTS_PATH="${qml_dir}/fonts/"
        printVerbose "Found fonts directory: ${WATCHFACE_FONTS_PATH}"
        
        # Set up fontconfig for custom fonts (same logic as testface)
        LOCAL_FONTCONFIG_BASE_PATH="${XDG_CONFIG_HOME:-$HOME/.config}/fontconfig"
        if [ ! -d "${LOCAL_FONTCONFIG_BASE_PATH}" ]; then
            echo "Warning: Cannot generate temporary fontconfig config file; " \
                 "fontconfig path ${LOCAL_FONTCONFIG_BASE_PATH} does not exist" >&2
        else
            LOCAL_FONTCONFIG_PATH="${LOCAL_FONTCONFIG_BASE_PATH}/conf.d"
            mkdir -p "$LOCAL_FONTCONFIG_PATH"
            local temp_font_config
            # Create temporary fontconfig file with 9999- prefix for last-in-order execution
            temp_font_config=$(mktemp -p "$LOCAL_FONTCONFIG_PATH" --suffix=".conf"  -t 9999-temp_font_config.XXXXXX) || { echo "Failed to generate temporary fontconfig config file" >&2; exit 1; }
            
            printVerbose "Generating temporary fontconfig config file \"${temp_font_config}\""
            
            # Set up cleanup trap
            trap "deleteTempFontconfig \"${temp_font_config}\"" EXIT
            
            # Generate fontconfig XML
            cat <<EOF > "${temp_font_config}"
<?xml version="1.0"?><!DOCTYPE fontconfig SYSTEM "fonts.dtd">
<fontconfig>
    <dir>${WATCHFACE_FONTS_PATH}/</dir>
</fontconfig>
EOF
        fi
    else
        printVerbose "No fonts directory found in ${qml_dir}"
    fi
    
    # Ensure wallpaper files exist
    if [ ! -f "${WALLPAPER}" ] ; then
        WALLPAPER="${SCRIPT_DIRPATH}/${WALLPAPER}"
    fi
    if [ ! -f "${WALLPAPER_ROUND}" ] ; then
        WALLPAPER_ROUND="${SCRIPT_DIRPATH}/${WALLPAPER_ROUND}"
    fi
    
    # Run qmlscene with the raw QML file
    # Pass the QML name (without extension), wallpapers, and the directory containing the QML file
    qmlscene "${qml_name}" "${WALLPAPER}" "${WALLPAPER_ROUND}" "${qml_dir}/" "${SCRIPT_DIRPATH}/loader.qml" -I "${SCRIPT_DIRPATH}/fake-components"
}

# Convert preview images for a watchface
# This function processes PNG preview images and converts them to various
# resolutions for both the watch and web display
# Args:
#   $1 - watchfacename: Name of the watchface
#   $2 - watchfacedir: Directory path of the watchface
function convertPreviews {
    local watchfacename="$1"
    local watchfacedir="$2"
    # Look for the transparent preview image
    local transparent="${watchfacename}-trans.png"
    local webResolution=320
    
    if [ -f "${transparent}" ] ; then
        echo "Converting ${transparent}"
        
        # Check if ImageMagick's magick command is available
        if ! command -v magick &> /dev/null ; then
            echo "Error: cannot find magick (part of ImageMagick) on path"
            exit 1
        fi
        
        # Generate the transparent thumbnail images for the watch
        # Various resolutions are needed for different watch models
        for res in 112 128 144 160 182 ; do
            respath="${watchfacedir}/usr/share/asteroid-launcher/watchfaces-preview/${res}"
            mkdir -p "${respath}"
            # Resize, sharpen, compress, and strip metadata
            magick "${transparent}" \
                -resize "${res}x${res}" -adaptive-sharpen 0x.8 -quality 70 -strip \
                "${respath}/${watchfacename}.png"
        done
        
        # Generate the thumbnail images for the web (README display)
        # Create both square and round versions
        for thumb in "${watchfacename}" "${watchfacename}-round" ; do
            magick "${thumb}.png" \
                -resize "${webResolution}x${webResolution}" -adaptive-sharpen 0x.4 -quality 85 \
                ".thumbnails/${thumb}.webp"
        done
        
        # Clean up the temporary preview PNG files
        rm "${watchfacename}.png" "${watchfacename}-round.png" "${transparent}"
        
        # Generate a markdown snippet for adding to README.md
        echo "| ![thumbnail](.thumbnails/${watchfacename}-round.webp) |![thumbnail](.thumbnails/${watchfacename}.webp) | [${watchfacename}](${watchfacename}/usr/share/asteroid-launcher/watchfaces/${watchfacename}.qml) | [yourname](https://github.com/yourname) |" > "${watchfacename}.md"
        echo "Add the contents of ${watchfacename}.md to README.md, adding font licenses and your name"
    else
        echo "Did not find ${transparent}"
    fi
}
 
# Clone a watchface (wrapper function for interactive use)
# Args:
#   $1 - sourcewatchfacename: Name of the source watchface
#   $2 - destwatchface: Name of the destination watchface
function cloneface {
    # Get the short name, stripping trailing '/' if any
    local sourcewatchfacename="${1%/*}"
    local destwatchface="$2"
    
    # Find the source watchface directory
    if ! sourcewatchfacedir=$(findWatchface "${sourcewatchfacename}") ; then
        exit 1
    fi
    
    echo "Cloning ${sourcewatchfacename} into ${destwatchface}"
    
    # Verify destination doesn't already exist
    if [ -e "${destwatchface}" ] ; then
        echo "Error:  ${destwatchface} already exists, exiting program"
        exit
    fi
    
    # Perform the clone operation
    watchfaceClone "${sourcewatchfacedir}" "${destwatchface}"
}

# ============================================================================
# Interactive Menu Functions
# ============================================================================

# Display a GUI menu using zenity for selecting and executing actions
# This provides a graphical interface for users who prefer GUI over terminal
function guiMenu {
    local watchface
    local action
    local default
    
    # Present a menu to select an action (deploy, clone, or test)
    if ! action=$(zenity --title="Select action" --list --radiolist \
        --column="selected" --column="action" \
        TRUE deploy \
        FALSE clone \
        FALSE test); then
        # User cancelled
        exit
    fi
    
    # Set the default selection state based on DEFAULTOPTION
    if [ "${DEFAULTOPTION}" == "ON" ] ; then
        default=TRUE
    else
        default=FALSE
    fi
    
    # Handle the selected action
    case $action in
        deploy)
            # For deploy, allow multiple selections via checklist
            declare -a args=('--title="Choose watchfaces"' "--list" "--checklist" '--column="Selected"' '--column="Name"')
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${default}" "${wf}")
            done
            if ! watchface=$(zenity "${args[@]}"); then
                exit
            fi
            ;;
        clone|test)
            # For clone and test, allow only single selection
            if ! watchface=$(zenity --title="Choose a watchface" --list --column="Name" "${WATCHFACES[@]}"); then
                exit
            fi
            ;;
    esac
    
    # Convert pipe chars to spaces (zenity uses | as separator for multiple selections)
    watchface=${watchface//|/ }
    
    # Confirm the action with the user
    if zenity --question --title="Confirming" --text="${action} ${watchface}" ; then
        echo "OK!"
        if [ "${action}" = "clone" ] ; then
            # For clone, prompt for the new watchface name
            if newface=$(zenity --entry --title="Cloning ${watchface}" \
                --text="Enter name of new watchface:" \
                --entry-text "newface")
            then cloneface "${watchface}" "${newface}"
            else echo "No name entered"
            fi
        elif [ "${action}" = "deploy" ] ; then
            # Deploy all selected watchfaces
            local first=true
            for wf in ${watchface}; do
                # Only activate the first watchface
                deployface "${wf}" "${first}"
                first=false
            done
            # Restart ceres session to recognize new watchfaces
            restartCeres
            # Reboot if requested
            if [ "${REBOOT}" = "true" ] ; then
                rebootWatch
            fi
        else
            # Test the selected watchface
            testface "${watchface}"
        fi
    else
        echo "Canceled"
    fi
}

# Display a text-based menu using dialog or whiptail
# This provides a terminal-based interactive menu for selecting actions
function textMenu {
    local args
    local watchface
    local newface
    
    # Present a menu to select an action (deploy, clone, or test)
    if ! action=$(${MENUPROGRAM} --title "Select action" --clear --radiolist \
        "Select action" 0 0 3 \
        "deploy" "Deploy watchface to watch" ON \
        "clone" "Clone watchface to new name" OFF \
        "test" "Test watchface on computer" OFF \
        3>&1 1>&2 2>&3); then
        # User cancelled
        exit
    fi
    
    # Handle the selected action
    case $action in
        deploy)
            # For deploy, show a checklist of all watchfaces
            declare -a args=("--title" "Watchfaces" "--clear" "--checklist" "Choose watchfaces:" 25 78 15 "--" )
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${wf}" "" "${DEFAULTOPTION}")
            done
            if ! watchface=$(${MENUPROGRAM} "${args[@]}" 3>&1 1>&2 2>&3); then
                exit
            fi
            ;;
        clone|test)
            # For clone and test, show a single-selection menu
            declare -a args=("--title" "Watchfaces" "--clear" "--menu" "Choose a watchface:" 25 78 15 "--" )
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${wf}" "")
            done
            if ! watchface=$(${MENUPROGRAM} "${args[@]}" 3>&1 1>&2 2>&3); then
                exit
            fi
            ;;
    esac
    
    # Confirm the action with the user
    if (${MENUPROGRAM} --clear --title "Confirming" --yesno "${action} ${watchface}" 0 0); then
        echo "OK!"
        if [ "${action}" = "clone" ] ; then
            # For clone, prompt for the new watchface name
            if newface=$(${MENUPROGRAM} \
                --title "Cloning ${watchface}" --clear \
                --inputbox "Enter name of new watchface:" \
                8 50 "newface" \
                3>&1 1>&2 2>&3)
            then
                cloneface "${watchface}" "${newface}"
            else
                echo "No name entered"
            fi
        elif [ "${action}" = "deploy" ] ; then
            # Deploy all selected watchfaces
            local first=true
            for wf in ${watchface}; do
                # Only activate the first watchface
                deployface "${wf}" "${first}"
                first=false
            done
            # Reboot if requested
            if [ "${REBOOT}" = "true" ] ; then
                rebootWatch
            fi
        else
            # Test the selected watchface
            testface "${watchface}"
        fi
    else
        echo "Canceled"
    fi
}

# Deploy all available watchfaces to the watch
# This is useful for setting up a watch with all watchfaces at once
function deployall {
    for wf in "${WATCHFACES[@]}" ; do
        # Deploy each watchface without activating it
        deployface "${wf}" false
    done
}


# ============================================================================
# Main Script Initialization
# ============================================================================

# Prevent the script from being sourced
# This script is meant to be executed directly, not sourced into another script
(return 0 2>/dev/null) && script_is_sourced=1 || script_is_sourced=0
if [ "$script_is_sourced" -gt 0 ]; then
    echo "You are trying to source this script. It is not meant to be sourced." >&2
    return
fi

# Determine which menu program to use (dialog or whiptail)
# Dialog is preferred if available, otherwise fall back to whiptail
if ! hash dialog 2>/dev/null; then
    MENUPROGRAM="dialog"
elif ! hash whiptail 2>/dev/null; then
    MENUPROGRAM="whiptail --separate-output"
fi

# Location of temporary font directory (currently unused)
FONT_DIR="${HOME}/.fonts"

# Temporary files and symlinks to delete (currently unused)
declare -a DELETE_LIST=()

# Get the directory path where this script is located
# This allows the script to find resources like loader.qml and fake-components
# regardless of where it's called from
SCRIPT_DIRPATH="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"

# ============================================================================
# Command-Line Argument Parsing
# ============================================================================

# Preprocess command line switches with getopt to rearrange
# them for easier parsing, separating non-option arguments
# and option arguments.
REARRANGED_OPTS=$(getopt -o 'abc:egqp:r:t:hw:v' --long 'adb,boot,circlewall:,every,gui,qemu,port:,remote:,transport:,help,wall:,verbose' -n "$0" -- "$@")
if [[ $? -ne 0 ]]; then
    echo "Error parsing arguments" >&2
    showHelp
    exit 1
fi

# Replace existing arguments with the rearranged ones
eval set -- "$REARRANGED_OPTS"
unset REARRANGED_OPTS

# Process all option flags
while true; do
    case "$1" in
        '-a'|'--adb')
            # Use ADB mode instead of SSH
            ADB=true
            shift
            ;;
        '-b'|'--boot')
            # Reboot watch after deploying watchfaces
            REBOOT=true
            shift
            ;;
        '-c'|'--circlewall')
            # Set custom wallpaper for circular display
            WALLPAPER_ROUND="$2"
            shift 2
            ;;
        '-e'|'--every')
            # Select all watchfaces by default in deploy menu
            DEFAULTOPTION=ON
            shift
            ;;
        '-g'|'--gui')
            # Use graphical (zenity) menu instead of text menu
            GUI=true
            shift
            ;;
        '-q'|'--qemu')
            # Connect to QEMU emulated watch
            WATCHPORT=${QEMUPORT}
            WATCHADDR=${QEMUADDR}
            shift
            ;;
        '-p'|'--port')
            # Custom SSH port
            WATCHPORT="$2"
            shift 2
            ;;
        '-r'|'--remote')
            # Custom watch IP address or hostname
            WATCHADDR="$2"
            shift 2
            ;;
        '-t'|'--transport')
            # ADB transport ID for multiple connected devices
            TRANSPORT_ID="-t $2"
            shift 2
            ;;
        '-h'|'--help')
            # Display help and exit
            showHelp
            exit 1
            ;;
        '-w'|'--wall')
            # Set custom wallpaper for square display
            WALLPAPER="$2"
            shift 2
            ;;
        '-v'|'--verbose')
            # Enable verbose output for debugging
            VERBOSE_MESSAGES=true
            shift
            ;;
        '--')
            # End of options marker
            shift
            break
            ;;
        *)
            # Should not reach here if getopt is working correctly
            echo "Internal error parsing arguments" >&2
            exit 1
            ;;
    esac
done

# Process remaining arguments as command and its arguments
if [[ $# -gt 0 ]]; then
    COMMAND="$1"
    shift
    COMMAND_ARGS=("$@")
fi

# ============================================================================
# Command Validation
# ============================================================================

# Validate that the command has the correct number of arguments
case "$COMMAND" in
    "clone")
        # clone requires source and destination watchface names
        if [[ ${#COMMAND_ARGS[@]} -ne 2 ]]; then
            echo "Error: clone command requires exactly 2 arguments (source and destination)" >&2
            exit 1
        fi
        ;;
    "deploy"|"test"|"raw")
        # deploy, test, and raw require exactly one argument
        if [[ ${#COMMAND_ARGS[@]} -ne 1 ]]; then
            echo "Error: $COMMAND command requires exactly 1 argument" >&2
            exit 1
        fi
        ;;
    "deployall"|"update"|"version")
        # These commands take no arguments
        if [[ ${#COMMAND_ARGS[@]} -ne 0 ]]; then
            echo "Error: $COMMAND command takes no arguments" >&2
            exit 1
        fi
        ;;
    "")
        # No command specified - this is OK for interactive mode
        ;;
    *)
        # Unknown command
        echo "Error: Unknown command '$COMMAND'" >&2
        showHelp
        exit 1
        ;;
esac

printVerbose "Script is located in directory path \"$SCRIPT_DIRPATH\""

# ============================================================================
# Command Execution
# ============================================================================

# Execute the specified command
case "$COMMAND" in
    "clone")
        # Clone a watchface to create a new one
        cloneface "${COMMAND_ARGS[0]}" "${COMMAND_ARGS[1]}"
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "deployall")
        # Deploy all watchfaces (handled later in the script)
        DEPLOY_ALL=true
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "deploy")
        # Deploy a single watchface and activate it
        deployface "${COMMAND_ARGS[0]}" true
        restartCeres
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "test")
        # Test a watchface locally
        testface "${COMMAND_ARGS[0]}"
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "raw")
        # Test a raw QML file
        testraw "${COMMAND_ARGS[0]}"
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "update")
        # Update the repository using git
        git pull
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "version")
        # Display version and exit
        showVersion
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "")
        # No command - will enter interactive mode
        echo "No command specified, entering interactive mode"
        ;;
esac

# ============================================================================
# Interactive Mode
# ============================================================================

# If no command was specified, start the interactive dialog
# Find all watchfaces in CWD first, then in script directory
# A watchface is identified by having the usr/share directory structure

# Find watchfaces in current working directory
mapfile -t CWD_WATCHFACES < <(find . -maxdepth 3 -type d -path "*/usr/share" 2>/dev/null | sed 's|/usr/share$||' | sort | awk -F '/' '{print $2}')

# Find watchfaces in script directory
mapfile -t SCRIPT_WATCHFACES < <(cd "${SCRIPT_DIRPATH}" && find . -maxdepth 3 -type d -path "*/usr/share" 2>/dev/null | sed 's|/usr/share$||' | sort | awk -F '/' '{print $2}')

# Combine both lists, removing duplicates (CWD takes precedence)
mapfile -t WATCHFACES < <(printf '%s\n' "${CWD_WATCHFACES[@]}" "${SCRIPT_WATCHFACES[@]}" | awk '!seen[$0]++')

# Start interactive mode if no command was executed
if [ "${SKIP_INTERACTIVE_PROMPT}" != "true" ] ; then
    if [ "${GUI}" = "true" ] ; then
        # GUI mode with zenity
        if ! hash zenity 2>/dev/null; then
            echo "Error: install 'zenity' to use gui menus."
        else
            guiMenu
        fi
    else
        # Text mode with dialog or whiptail
        if [ -z "${MENUPROGRAM}" ] ; then
            echo "Error: install either 'dialog' or 'whiptail' to use text menus."
        else
            textMenu
        fi
    fi
elif [ "${DEPLOY_ALL}" == "true" ] ; then
    # Execute deployall command (deferred to here so watchface list is populated)
    deployall
fi

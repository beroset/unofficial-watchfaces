#! /bin/bash
#
# watchface - Utility script for managing AsteroidOS watchfaces
#
# This script provides a comprehensive set of tools for deploying, testing,
# and managing watchfaces for AsteroidOS smartwatches. It supports both
# SSH (Developer Mode) and ADB (ADB Mode) communication methods.
#
# Key features:
# - Deploy watchfaces to an AsteroidOS watch
# - Test watchfaces locally using qmlscene
# - Clone existing watchfaces to create new ones
# - Interactive menu systems (text-based and GUI)
# - Automatic font configuration handling for custom fonts
# - Preview image generation and conversion
#
# Usage: ./watchface [options] [command] [arguments]
# See showHelp() function for detailed usage information.
#

# Version number of this script
VERSION="1.2"

# Display the current version of the script
function showVersion {
    echo "watchface v${VERSION}"
}

# Display comprehensive help information about the script
# This function prints the version and complete usage documentation
# including all available options and commands.
function showHelp {
    showVersion
    cat << EOF
watchface [option] [command...]
Utility functions for AsteroidOS watchfaces.  By default, uses "SSH Mode"
over ssh, but can also use "ADB Mode" using ADB.

Available options:
-h or --help            print this help screen and quit
-a or --adb             use ADB command to communicate with watch
-b or --boot            reboot watch after deploying multiple watchfaces
-c or --circlewall WP   set the wallpaper for circular watchface thumbnail to the named file (WP)
-e or --every           select every watchface (deploy only)
-g or --gui             use the GTK+ gui
-p or --port            specify an IP port to use for ssh and scp commands
-q or --qemu            communicate with QEMU emulated watch (same as -r localhost -p 2222 )
-r or --remote          specify the remote (watch)  name or address for ssh and scp commands
-t or --transport       when used win ADB mode, specifies the transport id
-w or --wall WP         set the wallpaper for deploy or test to the named file (WP)
-v or --verbose         print verbose messages (useful for debugging)

Available commands:
update          use git to update your local copy of the unoffical-watchfaces repository
version         display the version of this program and exit
deploy WF       push the named watchface to the watch and activate it
deployall       deploy all watchfaces
clone WF NEWWF  clone the named watchface WF to new watchface NEWWF
test WF         test the named watchface on the computer using qmlscene
raw QMLFILE     test a raw QML file without the standard directory structure

EOF
}

# ============================================================================
# Environment Configuration Variables
# ============================================================================
# These variables are set based on parsed command-line switches and control
# how the script communicates with the watch and which features are enabled.

# SSH connection settings (default for SSH mode)
# These are the defaults for SSH access to a watch on the local network
WATCHPORT=22                    # SSH port number
WATCHADDR=192.168.2.15          # Default IP address of the watch

# QEMU emulator connection settings
# These are the defaults for local QEMU target
QEMUPORT=2222                   # SSH port for QEMU
QEMUADDR=localhost              # QEMU runs on localhost

# Communication method flags
ADB=false                       # Use ADB mode instead of SSH (default: false)
GUI=false                       # Use GUI menu with zenity (default: false)

# Interactive mode control
# Only show interactive prompt if the user hasn't
# already specified a command on the command line
SKIP_INTERACTIVE_PROMPT=false

# Wallpaper configuration
# Default wallpaper files unless user specifies others
WALLPAPER="background.jpg"              # Square display wallpaper
WALLPAPER_ROUND="background-round.jpg"  # Circular display wallpaper

# Watchface deployment settings
DEFAULTOPTION=OFF               # Default to all watchfaces unselected for deploy
DEPLOY_ALL=false                # Default to not deploying all watchfaces

# Debug and logging
VERBOSE_MESSAGES=false          # Print verbose messages to stderr (default: false)

# ADB transport configuration
# Transport id is not needed unless multiple watches are connected
TRANSPORT_ID=

# Command execution state
COMMAND=""                      # Command to execute (deploy, test, clone, etc.)
declare -a COMMAND_ARGS=()      # Arguments for the command

# ============================================================================
# Core Communication Functions
# ============================================================================

# Execute a command on the watch as a specific user
# This function abstracts the difference between ADB and SSH communication
# Args:
#   $1 - user: Either "root" or "ceres" - the user to run the command as
#   $2 - cmd: The shell command to execute on the watch
# Returns: Exit status of the remote command
function runWatchCommand {
    local user="$1"
    local cmd=$2
    case ${user} in
        root)
            if [ "$ADB" = "true" ] ; then
                adb ${TRANSPORT_ID} shell "${cmd}"
            else
                ssh -p "${WATCHPORT}" -t root@"${WATCHADDR}" ${cmd}
            fi
            ;;
        ceres)
            if [ "$ADB" = "true" ] ; then
                printf -v cmd %q "${cmd}"
                adb ${TRANSPORT_ID} shell "su -l -c ${cmd} ceres"
            else
                ssh -p "${WATCHPORT}" -t ceres@"${WATCHADDR}" ${cmd}
            fi
            ;;
        *)
            echo "Error: unknown watch user ${user}"
            ;;
    esac
}

# Print a message only if verbose mode is enabled
# Args:
#   $1 - message: The message to print
function printVerbose {
   local message="$1"
   if [ "${VERBOSE_MESSAGES}" = "true" ] ; then
       echo "$message"
   fi
}

# Set a dconf configuration setting on the watch
# Args:
#   $1 - dconfsetting: The dconf key path (e.g., "/desktop/asteroid/watchface")
#   $2 - filename: The file path to set as the value
function setDconf {
    local dconfsetting="$1"
    local filename="$2"
    runWatchCommand "ceres" "dconf write ${dconfsetting} '\"file://${filename}\"'"
}

# Push files or directories to the watch
# This function abstracts the difference between ADB push and SCP
# Args:
#   $1 - user: The user account (for SSH mode, ignored for ADB)
#   $2 - sourcedir: Local source file or directory path
#   $3 - destdir: Remote destination path on the watch
function pushFiles {
    local user="$1"
    local sourcedir="$2"
    local destdir="$3"
    if [ "$ADB" = "true" ] ; then
        adb ${TRANSPORT_ID} push ${sourcedir} "${destdir}"
    else
        scp -P"${WATCHPORT}" -r ${sourcedir} "${user}@${WATCHADDR}:${destdir}"
    fi
}

# Push a watchface directory structure to the watch
# Args:
#   $1 - Watchface directory path containing usr/share/* structure
function pushWatchface {
    pushFiles "root" "${1}"'/usr/share/*' "/usr/share/"
}

# Push a wallpaper image to the watch and set it as the active background
# Args:
#   $1 - source: Local path to the wallpaper image file
function pushWallpaper {
    local source="$1"
    local wallpaper
    wallpaper="$(basename "$1")"
    local destination="/usr/share/asteroid-launcher/wallpapers/full/${wallpaper}"
    pushFiles "root" "${source}" "${destination}"
    setDconf "/desktop/asteroid/background-filename" "${destination}"
}

# Restart the ceres user session on the watch
# This is necessary after deploying new watchfaces or fonts
# to make them available to the launcher
function restartCeres {
    runWatchCommand "root" "systemctl restart user@1000"
}

# Reboot the entire watch
# Sometimes needed when ceres restart doesn't properly reset everything
function rebootWatch {
    runWatchCommand "ceres" "reboot"
}

# Activate a specific watchface on the watch
# Args:
#   $1 - Watchface name (without .qml extension)
function activateWatchface {
    setDconf "/desktop/asteroid/watchface" "/usr/share/asteroid-launcher/watchfaces/${1}.qml"
}

# ============================================================================
# Watchface Management Functions
# ============================================================================

# Clone a watchface to create a new one with a different name
# This copies all files and replaces occurrences of the source name
# with the destination name in paths and QML files
# Args:
#   $1 - source_path: Source watchface path (can be absolute)
#   $2 - dest_name: Destination watchface name (relative to CWD)
function watchfaceClone {
    local source_path="$1"
    local dest_name="$2"
    local files
    
    if [ ! -d "${source_path}" ] ; then
        echo "Error: source watchface path \"${source_path}\" does not exist" >&2
        exit 1
    fi
    
    local source_name
    source_name=$(basename "${source_path}")
    
    mapfile -t files <<<"$(cd "${source_path}" && find . -type f | sed 's|^\./||')"
    
    for file in "${files[@]}" ; do
        if [[ -z "${file}" ]] ; then
            continue
        fi
        
        local dest_file
        local destdir
        dest_file="${file//${source_name}/${dest_name}}"
        destdir="${dest_name}/$(dirname "${dest_file}")"
        
        mkdir -p "${destdir}"
        cp "${source_path}/${file}" "${dest_name}/${dest_file}"
        
        local extension="${dest_file##*.}"
        if [ "${extension}" = "qml" ] ; then
            sed -i "s/${source_name}/${dest_name}/g" "${dest_name}/${dest_file}"
        fi
    done
}

# Find a watchface by name, searching CWD first, then script directory
# This allows users to work on watchfaces in any location
# Args:
#   $1 - watchface_name: Watchface name (without trailing '/')
# Returns:
#   Outputs the full path to the watchface directory
#   Returns 0 if found, 1 if not found
function findWatchface {
    local watchface_name="$1"
    local cwd_path="${PWD}/${watchface_name}"
    local script_path="${SCRIPT_DIRPATH}/${watchface_name}"
    
    if [[ -d "${cwd_path}/usr/share/asteroid-launcher/watchfaces/" ]] ; then
        echo "${cwd_path}"
        return 0
    fi
    
    if [[ -d "${script_path}/usr/share/asteroid-launcher/watchfaces/" ]] ; then
        echo "${script_path}"
        return 0
    fi
    
    echo ""
    return 1
}

# Deploy a watchface to the watch
# Args:
#   $1 - sourcewatchfacename: Name of the watchface to deploy
#   $2 - activate: "true" to activate the watchface and push wallpaper, "false" otherwise
function deployface {
    local sourcewatchfacename="${1%/*}"
    local activate="$2"
    
    if ! sourcewatchfacedir=$(findWatchface "${sourcewatchfacename}") ; then
        exit 1
    fi
    
    echo "Deploying ${sourcewatchfacename}"
    pushWatchface "${sourcewatchfacedir}"
    
    if [ "${activate}" = "true" ] ; then
        activateWatchface "${sourcewatchfacename}"
        if [ -f "${WALLPAPER}" ] ; then
            pushWallpaper "${WALLPAPER}"
        fi
    fi
}

# Delete a temporary fontconfig configuration file
# This is called as a cleanup function via trap
# Args:
#   $1 - temp_font_config: Path to the temporary fontconfig file
function deleteTempFontconfig {
    local temp_font_config="$1"
    printVerbose "Deleting temporary fontconfig config file \"${temp_font_config}\""
    rm -f "${temp_font_config}"
}

# Test a watchface locally using qmlscene
# This function sets up the environment to test a watchface on the computer
# without deploying it to the watch. It handles custom fonts by creating
# temporary fontconfig configuration.
# Args:
#   $1 - sourcewatchfacename: Name of the watchface to test
function testface {
    local sourcewatchfacename="${1%/*}"
    
    if ! sourcewatchfacedir=$(findWatchface "${sourcewatchfacename}") ; then
        exit 1
    fi
    
    echo "Testing ${sourcewatchfacename}"

    WATCHFACE_FONTS_PATH="${sourcewatchfacedir}/usr/share/fonts/"

    if [ -d "${WATCHFACE_FONTS_PATH}" ]; then
        printVerbose "Watchface has custom fonts in path \"${WATCHFACE_FONTS_PATH}\""

        # Create a temporary fontconfig configuration file that points to the
        # fonts subdirectory of the watchface. This allows Qt to load the font
        # from that local directory - very useful when testing a watch, because
        # then, installing that font is not necessary. The temporary config is
        # generated in the local fontconfig config directory to let fontconfig
        # find it.
        # This is better than setting the FONTCONFIG_FILE environment variable
        # to point to the autogenerated file, because the latter approach will
        # use the autogenerated config file as a full replacement for the system
        # config. This causes the Qt UI itself to not find fonts for its widgets,
        # and can also cause the watchface to not show certain glyphs if they
        # are only available in fallback fonts.

        # Check for the presence of the base fontconfig path. If it does not
        # exist, then the autogenerated config below probably would not work
        # because fontconfig is not present or configured in an unknown fashion.
        # Exit with an error in that case.
        LOCAL_FONTCONFIG_BASE_PATH="${XDG_CONFIG_HOME:-$HOME/.config}/fontconfig"
        if [ ! -d "${LOCAL_FONTCONFIG_BASE_PATH}" ]; then
            echo "Cannot generate temporary fontconfig config file; " \
                 "fontconfig path ${LOCAL_FONTCONFIG_BASE_PATH} does not exist" >&2
            exit 1
        fi

        LOCAL_FONTCONFIG_PATH="${LOCAL_FONTCONFIG_BASE_PATH}/conf.d"
        mkdir -p "$LOCAL_FONTCONFIG_PATH"
        local temp_font_config
        # Use 9999- prefix to make sure this autogenerated configuration is applied
        # last, since fontconfig will list the config files in lexicographic order.
        # Also, the .conf suffix is used, since fontconfig requires that suffix;
        # it ignores files that do not end with ".conf".
        temp_font_config=$(mktemp -p "$CWD/$LOCAL_FONTCONFIG_PATH" --suffix=".conf"  -t 9999-temp_font_config.XXXXXX) || { echo "Failed to generate temporary fontconfig config file" >&2; exit 1; }

        printVerbose "Generating temporary fontconfig config file \"${temp_font_config}\""

        trap "deleteTempFontconfig \"${temp_font_config}\"" EXIT

        cat <<EOF > "${temp_font_config}"
<?xml version="1.0"?><!DOCTYPE fontconfig SYSTEM "fonts.dtd">
<fontconfig>
    <dir>${WATCHFACE_FONTS_PATH}/</dir>
</fontconfig>
EOF
    else
        printVerbose "Watchface has no custom fonts"
    fi

    if [ ! -f "${PWD}/${WALLPAPER}" ] ; then
        WALLPAPER="${SCRIPT_DIRPATH}/${WALLPAPER}"
    fi
    if [ ! -f "${PWD}/${WALLPAPER_ROUND}" ] ; then
        WALLPAPER_ROUND="${SCRIPT_DIRPATH}/${WALLPAPER_ROUND}"
    fi
    
    qmlscene "${sourcewatchfacename}" "${PWD}/${WALLPAPER}" "${PWD}/${WALLPAPER_ROUND}" "${sourcewatchfacedir}/usr/share/asteroid-launcher/watchfaces/" "${SCRIPT_DIRPATH}/loader.qml" -I "${SCRIPT_DIRPATH}/fake-components"
    
    convertPreviews "${sourcewatchfacename}" "${sourcewatchfacedir}"
}

# Test a raw QML file without the standard watchface directory structure
# This is useful for quick prototyping or testing standalone QML files
# Args:
#   $1 - qmlfile: Path to the QML file to test
function testraw {
    local qmlfile="$1"
    
    if [ ! -f "${qmlfile}" ] ; then
        echo "Error: QML file \"${qmlfile}\" does not exist" >&2
        exit 1
    fi
    
    local abs_qmlfile=$(readlink -f "${qmlfile}")
    local qml_dir=$(dirname "${abs_qmlfile}")
    local qml_basename=$(basename "${abs_qmlfile}")
    local qml_name="${qml_basename%.qml}"
    
    echo "Testing raw QML file: ${abs_qmlfile}"
    printVerbose "QML directory: ${qml_dir}"
    
    if [ -d "${qml_dir}/fonts" ]; then
        WATCHFACE_FONTS_PATH="${qml_dir}/fonts/"
        printVerbose "Found fonts directory: ${WATCHFACE_FONTS_PATH}"
        
        LOCAL_FONTCONFIG_BASE_PATH="${XDG_CONFIG_HOME:-$HOME/.config}/fontconfig"
        if [ ! -d "${LOCAL_FONTCONFIG_BASE_PATH}" ]; then
            echo "Warning: Cannot generate temporary fontconfig config file; " \
                 "fontconfig path ${LOCAL_FONTCONFIG_BASE_PATH} does not exist" >&2
        else
            LOCAL_FONTCONFIG_PATH="${LOCAL_FONTCONFIG_BASE_PATH}/conf.d"
            mkdir -p "$LOCAL_FONTCONFIG_PATH"
            local temp_font_config
            temp_font_config=$(mktemp -p "$LOCAL_FONTCONFIG_PATH" --suffix=".conf"  -t 9999-temp_font_config.XXXXXX) || { echo "Failed to generate temporary fontconfig config file" >&2; exit 1; }
            
            printVerbose "Generating temporary fontconfig config file \"${temp_font_config}\""
            
            trap "deleteTempFontconfig \"${temp_font_config}\"" EXIT
            
            cat <<EOF > "${temp_font_config}"
<?xml version="1.0"?><!DOCTYPE fontconfig SYSTEM "fonts.dtd">
<fontconfig>
    <dir>${WATCHFACE_FONTS_PATH}/</dir>
</fontconfig>
EOF
        fi
    else
        printVerbose "No fonts directory found in ${qml_dir}"
    fi
    
    if [ ! -f "${PWD}/${WALLPAPER}" ] ; then
        WALLPAPER="${SCRIPT_DIRPATH}/${WALLPAPER}"
    fi
    if [ ! -f "${PWD}/${WALLPAPER_ROUND}" ] ; then
        WALLPAPER_ROUND="${SCRIPT_DIRPATH}/${WALLPAPER_ROUND}"
    fi
    
    qmlscene "${qml_name}" "${PWD}/${WALLPAPER}" "${PWD}/${WALLPAPER_ROUND}" "${qml_dir}/" "${SCRIPT_DIRPATH}/loader.qml" -I "${SCRIPT_DIRPATH}/fake-components"
}

# Convert preview images for a watchface
# This function processes PNG preview images and converts them to various
# resolutions for both the watch and web display
# Args:
#   $1 - watchfacename: Name of the watchface
#   $2 - watchfacedir: Directory path of the watchface
function convertPreviews {
    local watchfacename="$1"
    local watchfacedir="$2"
    local transparent="${watchfacename}-trans.png"
    local webResolution=320
    
    if [ -f "${transparent}" ] ; then
        echo "Converting ${transparent}"
        
        if ! command -v magick &> /dev/null ; then
            echo "Error: cannot find magick (part of ImageMagick) on path"
            exit 1
        fi
        
        # Generate the transparent thumbnail images for the watch
        # Various resolutions are needed for different watch models
        for res in 112 128 144 160 182 ; do
            respath="${watchfacedir}/usr/share/asteroid-launcher/watchfaces-preview/${res}"
            mkdir -p "${respath}"
            magick "${transparent}" \
                -resize "${res}x${res}" -adaptive-sharpen 0x.8 -quality 70 -strip \
                "${respath}/${watchfacename}.png"
        done
        
        # Generate the thumbnail images for the web (README display)
        for thumb in "${watchfacename}" "${watchfacename}-round" ; do
            magick "${thumb}.png" \
                -resize "${webResolution}x${webResolution}" -adaptive-sharpen 0x.4 -quality 85 \
                ".thumbnails/${thumb}.webp"
        done
        
        rm "${watchfacename}.png" "${watchfacename}-round.png" "${transparent}"
        
        echo "| ![thumbnail](.thumbnails/${watchfacename}-round.webp) |![thumbnail](.thumbnails/${watchfacename}.webp) | [${watchfacename}](${watchfacename}/usr/share/asteroid-launcher/watchfaces/${watchfacename}.qml) | [yourname](https://github.com/yourname) |" > "${watchfacename}.md"
        echo "Add the contents of ${watchfacename}.md to README.md, adding font licenses and your name"
    else
        echo "Did not find ${transparent}"
    fi
}
 
# Clone a watchface (wrapper function for interactive use)
# Args:
#   $1 - sourcewatchfacename: Name of the source watchface
#   $2 - destwatchface: Name of the destination watchface
function cloneface {
    local sourcewatchfacename="${1%/*}"
    local destwatchface="$2"
    
    if ! sourcewatchfacedir=$(findWatchface "${sourcewatchfacename}") ; then
        exit 1
    fi
    
    echo "Cloning ${sourcewatchfacename} into ${destwatchface}"
    
    if [ -e "${destwatchface}" ] ; then
        echo "Error:  ${destwatchface} already exists, exiting program"
        exit
    fi
    
    watchfaceClone "${sourcewatchfacedir}" "${destwatchface}"
}

# ============================================================================
# Interactive Menu Functions
# ============================================================================

# Display a GUI menu using zenity for selecting and executing actions
# This provides a graphical interface for users who prefer GUI over terminal
function guiMenu {
    local watchface
    local action
    local default
    
    if ! action=$(zenity --title="Select action" --list --radiolist \
        --column="selected" --column="action" \
        TRUE deploy \
        FALSE clone \
        FALSE test); then
        exit
    fi
    
    if [ "${DEFAULTOPTION}" == "ON" ] ; then
        default=TRUE
    else
        default=FALSE
    fi
    
    case $action in
        deploy)
            declare -a args=('--title="Choose watchfaces"' "--list" "--checklist" '--column="Selected"' '--column="Name"')
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${default}" "${wf}")
            done
            if ! watchface=$(zenity "${args[@]}"); then
                exit
            fi
            ;;
        clone|test)
            if ! watchface=$(zenity --title="Choose a watchface" --list --column="Name" "${WATCHFACES[@]}"); then
                exit
            fi
            ;;
    esac
    
    watchface=${watchface//|/ }
    
    if zenity --question --title="Confirming" --text="${action} ${watchface}" ; then
        echo "OK!"
        if [ "${action}" = "clone" ] ; then
            if newface=$(zenity --entry --title="Cloning ${watchface}" \
                --text="Enter name of new watchface:" \
                --entry-text "newface")
            then cloneface "${watchface}" "${newface}"
            else echo "No name entered"
            fi
        elif [ "${action}" = "deploy" ] ; then
            local first=true
            for wf in ${watchface}; do
                deployface "${wf}" "${first}"
                first=false
            done
            restartCeres
            if [ "${REBOOT}" = "true" ] ; then
                rebootWatch
            fi
        else
            testface "${watchface}"
        fi
    else
        echo "Canceled"
    fi
}

# Display a text-based menu using dialog or whiptail
# This provides a terminal-based interactive menu for selecting actions
function textMenu {
    local args
    local watchface
    local newface
    
    if ! action=$(${MENUPROGRAM} --title "Select action" --clear --radiolist \
        "Select action" 0 0 3 \
        "deploy" "Deploy watchface to watch" ON \
        "clone" "Clone watchface to new name" OFF \
        "test" "Test watchface on computer" OFF \
        3>&1 1>&2 2>&3); then
        exit
    fi
    
    case $action in
        deploy)
            declare -a args=("--title" "Watchfaces" "--clear" "--checklist" "Choose watchfaces:" 25 78 15 "--" )
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${wf}" "" "${DEFAULTOPTION}")
            done
            if ! watchface=$(${MENUPROGRAM} "${args[@]}" 3>&1 1>&2 2>&3); then
                exit
            fi
            ;;
        clone|test)
            declare -a args=("--title" "Watchfaces" "--clear" "--menu" "Choose a watchface:" 25 78 15 "--" )
            for wf in "${WATCHFACES[@]}" ; do
                args+=("${wf}" "")
            done
            if ! watchface=$(${MENUPROGRAM} "${args[@]}" 3>&1 1>&2 2>&3); then
                exit
            fi
            ;;
    esac
    
    if (${MENUPROGRAM} --clear --title "Confirming" --yesno "${action} ${watchface}" 0 0); then
        echo "OK!"
        if [ "${action}" = "clone" ] ; then
            if newface=$(${MENUPROGRAM} \
                --title "Cloning ${watchface}" --clear \
                --inputbox "Enter name of new watchface:" \
                8 50 "newface" \
                3>&1 1>&2 2>&3)
            then
                cloneface "${watchface}" "${newface}"
            else
                echo "No name entered"
            fi
        elif [ "${action}" = "deploy" ] ; then
            local first=true
            for wf in ${watchface}; do
                deployface "${wf}" "${first}"
                first=false
            done
            if [ "${REBOOT}" = "true" ] ; then
                rebootWatch
            fi
        else
            testface "${watchface}"
        fi
    else
        echo "Canceled"
    fi
}

# Deploy all available watchfaces to the watch
# This is useful for setting up a watch with all watchfaces at once
function deployall {
    for wf in "${WATCHFACES[@]}" ; do
        # Deploy each watchface without activating it
        deployface "${wf}" false
    done
}


# ============================================================================
# Main Script Initialization
# ============================================================================

# Prevent the script from being sourced
# This script is meant to be executed directly, not sourced into another script
(return 0 2>/dev/null) && script_is_sourced=1 || script_is_sourced=0
if [ "$script_is_sourced" -gt 0 ]; then
    echo "You are trying to source this script. It is not meant to be sourced." >&2
    return
fi

# Determine which menu program to use (dialog or whiptail)
# Dialog is preferred if available, otherwise fall back to whiptail
if hash dialog 2>/dev/null; then
    MENUPROGRAM="dialog"
elif hash whiptail 2>/dev/null; then
    MENUPROGRAM="whiptail --separate-output"
fi

# Location of temporary font directory (currently unused)
FONT_DIR="${HOME}/.fonts"

# Temporary files and symlinks to delete (currently unused)
declare -a DELETE_LIST=()

# Get the directory path where this script is located
# This allows the script to find resources like loader.qml and fake-components
# regardless of where it's called from
SCRIPT_DIRPATH="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"

# ============================================================================
# Command-Line Argument Parsing
# ============================================================================

# Preprocess command line switches with getopt to rearrange
# them for easier parsing, separating non-option arguments
# and option arguments.
REARRANGED_OPTS=$(getopt -o 'abc:egqp:r:t:hw:v' --long 'adb,boot,circlewall:,every,gui,qemu,port:,remote:,transport:,help,wall:,verbose' -n "$0" -- "$@")
if [[ $? -ne 0 ]]; then
    echo "Error parsing arguments" >&2
    showHelp
    exit 1
fi

# Replace existing arguments with the rearranged ones
eval set -- "$REARRANGED_OPTS"
unset REARRANGED_OPTS

# Process all option flags
while true; do
    case "$1" in
        '-a'|'--adb')
            ADB=true
            shift
            ;;
        '-b'|'--boot')
            REBOOT=true
            shift
            ;;
        '-c'|'--circlewall')
            WALLPAPER_ROUND="$2"
            shift 2
            ;;
        '-e'|'--every')
            DEFAULTOPTION=ON
            shift
            ;;
        '-g'|'--gui')
            GUI=true
            shift
            ;;
        '-q'|'--qemu')
            WATCHPORT=${QEMUPORT}
            WATCHADDR=${QEMUADDR}
            shift
            ;;
        '-p'|'--port')
            WATCHPORT="$2"
            shift 2
            ;;
        '-r'|'--remote')
            WATCHADDR="$2"
            shift 2
            ;;
        '-t'|'--transport')
            TRANSPORT_ID="-t $2"
            shift 2
            ;;
        '-h'|'--help')
            showHelp
            exit 1
            ;;
        '-w'|'--wall')
            WALLPAPER="$2"
            shift 2
            ;;
        '-v'|'--verbose')
            VERBOSE_MESSAGES=true
            shift
            ;;
        '--')
            shift
            break
            ;;
        *)
            echo "Internal error parsing arguments" >&2
            exit 1
            ;;
    esac
done

# Process remaining arguments as command and its arguments
if [[ $# -gt 0 ]]; then
    COMMAND="$1"
    shift
    COMMAND_ARGS=("$@")
fi

# ============================================================================
# Command Validation
# ============================================================================

# Validate that the command has the correct number of arguments
case "$COMMAND" in
    "clone")
        if [[ ${#COMMAND_ARGS[@]} -ne 2 ]]; then
            echo "Error: clone command requires exactly 2 arguments (source and destination)" >&2
            exit 1
        fi
        ;;
    "deploy"|"test"|"raw")
        if [[ ${#COMMAND_ARGS[@]} -ne 1 ]]; then
            echo "Error: $COMMAND command requires exactly 1 argument" >&2
            exit 1
        fi
        ;;
    "deployall"|"update"|"version")
        if [[ ${#COMMAND_ARGS[@]} -ne 0 ]]; then
            echo "Error: $COMMAND command takes no arguments" >&2
            exit 1
        fi
        ;;
    "")
        ;;
    *)
        echo "Error: Unknown command '$COMMAND'" >&2
        showHelp
        exit 1
        ;;
esac

printVerbose "Script is located in directory path \"$SCRIPT_DIRPATH\""

# ============================================================================
# Command Execution
# ============================================================================

case "$COMMAND" in
    "clone")
        cloneface "${COMMAND_ARGS[0]}" "${COMMAND_ARGS[1]}"
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "deployall")
        DEPLOY_ALL=true
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "deploy")
        deployface "${COMMAND_ARGS[0]}" true
        restartCeres
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "test")
        testface "${COMMAND_ARGS[0]}"
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "raw")
        testraw "${COMMAND_ARGS[0]}"
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "update")
        git pull
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "version")
        showVersion
        SKIP_INTERACTIVE_PROMPT=true
        ;;
    "")
        echo "No command specified, entering interactive mode"
        ;;
esac

# ============================================================================
# Interactive Mode
# ============================================================================

# If no command was specified, start the interactive dialog
# Find all watchfaces in CWD first, then in script directory
# A watchface is identified by having the usr/share directory structure

mapfile -t CWD_WATCHFACES < <(find . -maxdepth 3 -type d -path "*/usr/share" 2>/dev/null | sed 's|/usr/share$||' | sort | awk -F '/' '{print $2}')

mapfile -t SCRIPT_WATCHFACES < <(cd "${SCRIPT_DIRPATH}" && find . -maxdepth 3 -type d -path "*/usr/share" 2>/dev/null | sed 's|/usr/share$||' | sort | awk -F '/' '{print $2}')

mapfile -t WATCHFACES < <(printf '%s\n' "${CWD_WATCHFACES[@]}" "${SCRIPT_WATCHFACES[@]}" | awk '!seen[$0]++')

# Start interactive mode if no command was executed
if [ "${SKIP_INTERACTIVE_PROMPT}" != "true" ] ; then
    if [ "${GUI}" = "true" ] ; then
        if hash zenity 2>/dev/null; then
            guiMenu
        else
            echo "Error: install 'zenity' to use gui menus."
        fi
    else
        if [ -z "${MENUPROGRAM}" ] ; then
            echo "Error: install either 'dialog' or 'whiptail' to use text menus."
        else
            textMenu
        fi
    fi
elif [ "${DEPLOY_ALL}" == "true" ] ; then
    deployall
fi
